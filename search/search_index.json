{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Robotika Str\u00e1nky pre kr\u00fa\u017eok robotiky so stavebnicou LEGO Mindstorms EV3 . Namiesto stavebnice je mo\u017en\u00e9 vyu\u017ei\u0165 simul\u00e1tor . N\u00e1vod na jeho pou\u017eitie n\u00e1jdete v z\u00e1lo\u017eke Simul\u00e1tor .","title":"\u00davod"},{"location":"#robotika","text":"Str\u00e1nky pre kr\u00fa\u017eok robotiky so stavebnicou LEGO Mindstorms EV3 . Namiesto stavebnice je mo\u017en\u00e9 vyu\u017ei\u0165 simul\u00e1tor . N\u00e1vod na jeho pou\u017eitie n\u00e1jdete v z\u00e1lo\u017eke Simul\u00e1tor .","title":"Robotika"},{"location":"simulator/","text":"Simul\u00e1tor Simul\u00e1tor n\u00e1jdete na str\u00e1nke gears.aposteriori.com.sg/ . V\u013eavo hore s\u00fa z\u00e1lo\u017eky: Blocks , ktor\u00fa nebudeme pou\u017e\u00edva\u0165; Python , kde budeme p\u00edsa\u0165 na\u0161e programy; A Simulator , kde spust\u00edme robota v simulovanom prostred\u00ed. \u010ealej na hornej li\u0161te m\u00f4\u017eeme vybra\u0165 robota a jeho okolie, ktor\u00e9 boli predpripraven\u00e9: Robot -> Select Robot , Worlds -> Select World . Alebo je mo\u017en\u00e9 si ich upravi\u0165 Robot -> Robot Configurator , Worlds -> World Builder . Po ich \u00faprave je potrebn\u00e9 si ich ulo\u017ei\u0165 do po\u010d\u00edta\u010du a potom nahra\u0165 do simul\u00e1toru: Robot / Worlds -> Load from file . Tip Pri \u00faloh\u00e1ch na tejto str\u00e1nke nie je potrebn\u00e9 robota ani okolie nijak nastavova\u0165, v\u017edy na za\u010diatku n\u00e1jdete odkaz na upraven\u00fd simul\u00e1tor. Napr. hne\u010f prv\u00e1 lekcia . Spustenie programu Ke\u010f u\u017e m\u00e1te v z\u00e1lo\u017eke Python nap\u00edsan\u00fd nejak\u00fd program, prepnite sa do z\u00e1lo\u017eky Simulator . V\u013eavo hore, pod hornou li\u0161tou, n\u00e1jdete tla\u010didlo \"\u0161tart\" (mal\u00fd biely trojuholn\u00edk). N\u00edm sa program spust\u00ed. Vpravo od neho je tla\u010didlo (biely kruh so \u0161\u00edpkou na konci) pre resetovanie sc\u00e9ny, vr\u00e1tenie robota do p\u00f4vodnej poz\u00edcie.","title":"Simul\u00e1tor"},{"location":"simulator/#simulator","text":"Simul\u00e1tor n\u00e1jdete na str\u00e1nke gears.aposteriori.com.sg/ . V\u013eavo hore s\u00fa z\u00e1lo\u017eky: Blocks , ktor\u00fa nebudeme pou\u017e\u00edva\u0165; Python , kde budeme p\u00edsa\u0165 na\u0161e programy; A Simulator , kde spust\u00edme robota v simulovanom prostred\u00ed. \u010ealej na hornej li\u0161te m\u00f4\u017eeme vybra\u0165 robota a jeho okolie, ktor\u00e9 boli predpripraven\u00e9: Robot -> Select Robot , Worlds -> Select World . Alebo je mo\u017en\u00e9 si ich upravi\u0165 Robot -> Robot Configurator , Worlds -> World Builder . Po ich \u00faprave je potrebn\u00e9 si ich ulo\u017ei\u0165 do po\u010d\u00edta\u010du a potom nahra\u0165 do simul\u00e1toru: Robot / Worlds -> Load from file . Tip Pri \u00faloh\u00e1ch na tejto str\u00e1nke nie je potrebn\u00e9 robota ani okolie nijak nastavova\u0165, v\u017edy na za\u010diatku n\u00e1jdete odkaz na upraven\u00fd simul\u00e1tor. Napr. hne\u010f prv\u00e1 lekcia .","title":"Simul\u00e1tor"},{"location":"simulator/#spustenie-programu","text":"Ke\u010f u\u017e m\u00e1te v z\u00e1lo\u017eke Python nap\u00edsan\u00fd nejak\u00fd program, prepnite sa do z\u00e1lo\u017eky Simulator . V\u013eavo hore, pod hornou li\u0161tou, n\u00e1jdete tla\u010didlo \"\u0161tart\" (mal\u00fd biely trojuholn\u00edk). N\u00edm sa program spust\u00ed. Vpravo od neho je tla\u010didlo (biely kruh so \u0161\u00edpkou na konci) pre resetovanie sc\u00e9ny, vr\u00e1tenie robota do p\u00f4vodnej poz\u00edcie.","title":"Spustenie programu"},{"location":"2motors/bonus/","text":"Bonusov\u00e1 \u00faloha Tancovanie s robotom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # BONUS: Vyberte si jednu p\u00edsni\u010dku a zkuste vymyslet jednoduchou choreografii # pro va\u0161eho robota. Zn\u00e1te u\u017e v\u0161echny mo\u017en\u00e9 pohyby, kter\u00e9 robot zvl\u00e1dne. lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () Tip An der sch\u00f6nen, blauen Donau","title":"Bonus"},{"location":"2motors/bonus/#bonusova-uloha","text":"Tancovanie s robotom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # BONUS: Vyberte si jednu p\u00edsni\u010dku a zkuste vymyslet jednoduchou choreografii # pro va\u0161eho robota. Zn\u00e1te u\u017e v\u0161echny mo\u017en\u00e9 pohyby, kter\u00e9 robot zvl\u00e1dne. lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () Tip An der sch\u00f6nen, blauen Donau","title":"Bonusov\u00e1 \u00faloha"},{"location":"2motors/lesson/","text":"Prv\u00fd robot V tejto \u010dasti budeme pracova\u0165 s ve\u013emi jednoduch\u00fdm robotom, bude ma\u0165 len dva motory, aby sa vedel pohybova\u0165. N\u00e1vod na stavbu robota n\u00e1jdete tu . V simul\u00e1tori mu odpoved\u00e1 toto prostredie . Program pre robota Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () # V\u0161echny \u0159\u00e1dky, kter\u00e9 za\u010d\u00ednaj\u00ed m\u0159\u00ed\u017ekou '#', jsou tzv. \"koment\u00e1\u0159e\". # To znamen\u00e1, \u017ee jsou to pozn\u00e1mky program\u00e1tora, nap\u0159. aby n\u011bco nezapomn\u011bl. # Robot tyto \u0159\u00e1dky ignoruje, jako by tam nebyly. My toho vyu\u017eijeme, abychom si # vysv\u011btlili novou l\u00e1tku. # # Tento k\u00f3d je podobn\u00fd tomu z minul\u00e9 hodiny. Prvn\u00edch 5 \u0159\u00e1dk\u016f je magick\u00fdch, # zat\u00edm to berme tak, \u017ee je prost\u011b t\u0159eba je napsat. # # N\u00e1sleduje `left_motor = Motor( Port.B )`. T\u00edm \u0159ekneme robotovi, \u017ee m\u00e1 # na portu \"B\" p\u0159ipojen\u00fd motor. To je prav\u00e1 strana `Motor( Port.B )`, vytvo\u0159\u00ed # se tak v pam\u011bti robota n\u011bco jako motor. Nen\u00ed to takov\u00fd motor, jak\u00fd ho vid\u00edme # v realit\u011b, nen\u00ed to fyzick\u00fd, hmotn\u00fd motor. Podobn\u011b jako n\u00e1m se do pam\u011bti # nedostane moucha, kdy\u017e se u\u010d\u00edme na p\u00edsemku z biologie. M\u00e1me v hlav\u011b n\u011bco, # co p\u0159ipom\u00edn\u00e1 mouchu, pamatujeme si jak vypad\u00e1, jak se chov\u00e1. Stejn\u011b tak robot # nem\u00e1 v pam\u011bti motor ale v\u00ed jak vypad\u00e1 a jak ho m\u00e1 ovl\u00e1dat, i to, \u017ee je # p\u0159ipojen na portu \"B\". Nyn\u00ed je\u0161t\u011b pot\u0159ebujeme tento motor pojmenovat. # To se ud\u011bl\u00e1 tak, \u017ee na levou stranu od rovn\u00edtka \"=\" nap\u00ed\u0161eme n\u00e1zev. Jakoby # si robot nalepil na motor pozn\u00e1mku \"lavy_motor\". On tomu nerozum\u00ed, stejn\u011b # tak bychom ho mohli nazvat \u201evsvrbsbd\u201c. Ale pro n\u00e1s program\u00e1tory je to snaz\u0161\u00ed, # kdy\u017e naz\u00fdv\u00e1me prom\u011bnn\u00e9 spr\u00e1vn\u011b. \"Prom\u011bnn\u00e9\" - to je nov\u00e9 slovo, mysl\u00edme j\u00edm # hodnotu (nap\u0159. motor v pam\u011bti nebo \u010d\u00edslo) sv\u00e1zanou s n\u00e1zvem. # # Stejn\u011b vytvo\u0159\u00edme \"pravy_motor\". Ten je p\u0159ipojen na portu \"C\". # # `lavy_motor.run( 360 )` -- \"lavy_motor\" robot u\u017e m\u00e1 v pam\u011bti, najde si ho # a rozto\u010d\u00ed. Te\u010dku \".\" p\u00ed\u0161eme za n\u00e1zvem prom\u011bnn\u00e9, pak n\u00e1sleduje \"metoda, # kterou zavol\u00e1me\". Co je to \"zavolat metodu\"? \"metoda\" je n\u011bjak\u00fd jin\u00fd program, # podprogram. Napsal ho n\u011bkdo jin\u00fd, stejn\u011b jako my te\u010f p\u00ed\u0161eme hlavn\u00ed # program. Kdy\u017e se metoda \"zavol\u00e1\", znamen\u00e1 to, \u017ee se tento podprogram spust\u00ed. # Nyn\u00ed se spust\u00ed podprogram `run( 360 )` -- Motor se rozto\u010d\u00ed rychlost\u00ed 360 # stup\u0148\u016f za sekundu. V\u00edme, \u017ee kruh m\u00e1 360 stup\u0148\u016f. Tak\u017ee za jednu vte\u0159inu # se kolo p\u0159ipojen\u00e9 na motor oto\u010d\u00ed o celou jednu oto\u010dku. Stejn\u011b spust\u00edme i # druh\u00fd motor \"pravy_motor\", nyn\u00ed se oba to\u010d\u00ed, dokud je nevypneme. # # `wait( 2000 )` jednodu\u0161e zp\u016fsob\u00ed, \u017ee robot bude 2000ms (= 2s) \u010dekat. Ale # pozor, motory jsou ji\u017e spu\u0161t\u011bny, to znamen\u00e1, \u017ee se po cel\u00e9 tyto dv\u011b sekundy # to\u010d\u00ed. \"wait\" je tak\u00e9 podprogram. Tentokr\u00e1t ale nep\u00ed\u0161eme \u017e\u00e1dkou te\u010dku a # n\u011bco p\u0159ed n\u00ed. \"lavy_motor.run\" byla metoda, je tam i te\u010dka. Bez te\u010dky # se to naz\u00fdv\u00e1 \"funkce\". \"run\" samo o sob\u011b nev\u00ed, kter\u00fd motor m\u00e1 spustit. # Proto je tam i ta te\u010dka \"lavy_motor.run\". Ale \"wait\" je jen jedno, pro # jednoho robota, ned\u00e1 se, aby nap\u0159. jen motor \u010dekal. Cel\u00fd robot \u010dek\u00e1. # # Na konci oba motory vypneme, pomoc\u00ed metody \"stop\". Spustenie programu V robotovi V simul\u00e1tori Nyn\u00ed se nau\u010d\u00edme jak program nahr\u00e1t do robota. Otev\u0159ete si str\u00e1nku https://xlcteam.github.io/RLLR/04/ a p\u0159ibli\u017en\u011b v polovin\u011b str\u00e1nky najdeme postup na v\u00edce krok\u016f. Za\u010dneme od kroku 7: \"Teraz zapneme EV3-kocku...\" a skon\u010d\u00edme krokem 12. Skop\u00edrujte k\u00f3d nap\u00edsan\u00fd vy\u0161\u0161ie do z\u00e1lo\u017eky \"Python\" v simul\u00e1tori. N\u00e1vod na spustenie programu tu . Varovanie M\u00f4\u017ee nasta\u0165 probl\u00e9m, ke\u010f simul\u00e1tor nedobre napodob\u0148uje robota v realite. M\u00e1 ve\u013ek\u00fa zotrva\u010dnos\u0165 a po vypnut\u00ed motorov sa robot (v simul\u00e1tori) aj tak st\u00e1le h\u00fdbe vpred, hoci re\u00e1lny robot by st\u00e1l na mieste. Rie\u0161en\u00edm je prep\u00edsa\u0165 v\u0161etky .stop() na .hold() . To zaru\u010d\u00ed, \u017ee sa koles\u00e1 u\u017e nebud\u00fa \u010falej h\u00fdba\u0165 zotrva\u010dnos\u0165ou.","title":"\u00davod"},{"location":"2motors/lesson/#prvy-robot","text":"V tejto \u010dasti budeme pracova\u0165 s ve\u013emi jednoduch\u00fdm robotom, bude ma\u0165 len dva motory, aby sa vedel pohybova\u0165. N\u00e1vod na stavbu robota n\u00e1jdete tu . V simul\u00e1tori mu odpoved\u00e1 toto prostredie .","title":"Prv\u00fd robot"},{"location":"2motors/lesson/#program-pre-robota","text":"Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () # V\u0161echny \u0159\u00e1dky, kter\u00e9 za\u010d\u00ednaj\u00ed m\u0159\u00ed\u017ekou '#', jsou tzv. \"koment\u00e1\u0159e\". # To znamen\u00e1, \u017ee jsou to pozn\u00e1mky program\u00e1tora, nap\u0159. aby n\u011bco nezapomn\u011bl. # Robot tyto \u0159\u00e1dky ignoruje, jako by tam nebyly. My toho vyu\u017eijeme, abychom si # vysv\u011btlili novou l\u00e1tku. # # Tento k\u00f3d je podobn\u00fd tomu z minul\u00e9 hodiny. Prvn\u00edch 5 \u0159\u00e1dk\u016f je magick\u00fdch, # zat\u00edm to berme tak, \u017ee je prost\u011b t\u0159eba je napsat. # # N\u00e1sleduje `left_motor = Motor( Port.B )`. T\u00edm \u0159ekneme robotovi, \u017ee m\u00e1 # na portu \"B\" p\u0159ipojen\u00fd motor. To je prav\u00e1 strana `Motor( Port.B )`, vytvo\u0159\u00ed # se tak v pam\u011bti robota n\u011bco jako motor. Nen\u00ed to takov\u00fd motor, jak\u00fd ho vid\u00edme # v realit\u011b, nen\u00ed to fyzick\u00fd, hmotn\u00fd motor. Podobn\u011b jako n\u00e1m se do pam\u011bti # nedostane moucha, kdy\u017e se u\u010d\u00edme na p\u00edsemku z biologie. M\u00e1me v hlav\u011b n\u011bco, # co p\u0159ipom\u00edn\u00e1 mouchu, pamatujeme si jak vypad\u00e1, jak se chov\u00e1. Stejn\u011b tak robot # nem\u00e1 v pam\u011bti motor ale v\u00ed jak vypad\u00e1 a jak ho m\u00e1 ovl\u00e1dat, i to, \u017ee je # p\u0159ipojen na portu \"B\". Nyn\u00ed je\u0161t\u011b pot\u0159ebujeme tento motor pojmenovat. # To se ud\u011bl\u00e1 tak, \u017ee na levou stranu od rovn\u00edtka \"=\" nap\u00ed\u0161eme n\u00e1zev. Jakoby # si robot nalepil na motor pozn\u00e1mku \"lavy_motor\". On tomu nerozum\u00ed, stejn\u011b # tak bychom ho mohli nazvat \u201evsvrbsbd\u201c. Ale pro n\u00e1s program\u00e1tory je to snaz\u0161\u00ed, # kdy\u017e naz\u00fdv\u00e1me prom\u011bnn\u00e9 spr\u00e1vn\u011b. \"Prom\u011bnn\u00e9\" - to je nov\u00e9 slovo, mysl\u00edme j\u00edm # hodnotu (nap\u0159. motor v pam\u011bti nebo \u010d\u00edslo) sv\u00e1zanou s n\u00e1zvem. # # Stejn\u011b vytvo\u0159\u00edme \"pravy_motor\". Ten je p\u0159ipojen na portu \"C\". # # `lavy_motor.run( 360 )` -- \"lavy_motor\" robot u\u017e m\u00e1 v pam\u011bti, najde si ho # a rozto\u010d\u00ed. Te\u010dku \".\" p\u00ed\u0161eme za n\u00e1zvem prom\u011bnn\u00e9, pak n\u00e1sleduje \"metoda, # kterou zavol\u00e1me\". Co je to \"zavolat metodu\"? \"metoda\" je n\u011bjak\u00fd jin\u00fd program, # podprogram. Napsal ho n\u011bkdo jin\u00fd, stejn\u011b jako my te\u010f p\u00ed\u0161eme hlavn\u00ed # program. Kdy\u017e se metoda \"zavol\u00e1\", znamen\u00e1 to, \u017ee se tento podprogram spust\u00ed. # Nyn\u00ed se spust\u00ed podprogram `run( 360 )` -- Motor se rozto\u010d\u00ed rychlost\u00ed 360 # stup\u0148\u016f za sekundu. V\u00edme, \u017ee kruh m\u00e1 360 stup\u0148\u016f. Tak\u017ee za jednu vte\u0159inu # se kolo p\u0159ipojen\u00e9 na motor oto\u010d\u00ed o celou jednu oto\u010dku. Stejn\u011b spust\u00edme i # druh\u00fd motor \"pravy_motor\", nyn\u00ed se oba to\u010d\u00ed, dokud je nevypneme. # # `wait( 2000 )` jednodu\u0161e zp\u016fsob\u00ed, \u017ee robot bude 2000ms (= 2s) \u010dekat. Ale # pozor, motory jsou ji\u017e spu\u0161t\u011bny, to znamen\u00e1, \u017ee se po cel\u00e9 tyto dv\u011b sekundy # to\u010d\u00ed. \"wait\" je tak\u00e9 podprogram. Tentokr\u00e1t ale nep\u00ed\u0161eme \u017e\u00e1dkou te\u010dku a # n\u011bco p\u0159ed n\u00ed. \"lavy_motor.run\" byla metoda, je tam i te\u010dka. Bez te\u010dky # se to naz\u00fdv\u00e1 \"funkce\". \"run\" samo o sob\u011b nev\u00ed, kter\u00fd motor m\u00e1 spustit. # Proto je tam i ta te\u010dka \"lavy_motor.run\". Ale \"wait\" je jen jedno, pro # jednoho robota, ned\u00e1 se, aby nap\u0159. jen motor \u010dekal. Cel\u00fd robot \u010dek\u00e1. # # Na konci oba motory vypneme, pomoc\u00ed metody \"stop\".","title":"Program pre robota"},{"location":"2motors/lesson/#spustenie-programu","text":"V robotovi V simul\u00e1tori Nyn\u00ed se nau\u010d\u00edme jak program nahr\u00e1t do robota. Otev\u0159ete si str\u00e1nku https://xlcteam.github.io/RLLR/04/ a p\u0159ibli\u017en\u011b v polovin\u011b str\u00e1nky najdeme postup na v\u00edce krok\u016f. Za\u010dneme od kroku 7: \"Teraz zapneme EV3-kocku...\" a skon\u010d\u00edme krokem 12. Skop\u00edrujte k\u00f3d nap\u00edsan\u00fd vy\u0161\u0161ie do z\u00e1lo\u017eky \"Python\" v simul\u00e1tori. N\u00e1vod na spustenie programu tu . Varovanie M\u00f4\u017ee nasta\u0165 probl\u00e9m, ke\u010f simul\u00e1tor nedobre napodob\u0148uje robota v realite. M\u00e1 ve\u013ek\u00fa zotrva\u010dnos\u0165 a po vypnut\u00ed motorov sa robot (v simul\u00e1tori) aj tak st\u00e1le h\u00fdbe vpred, hoci re\u00e1lny robot by st\u00e1l na mieste. Rie\u0161en\u00edm je prep\u00edsa\u0165 v\u0161etky .stop() na .hold() . To zaru\u010d\u00ed, \u017ee sa koles\u00e1 u\u017e nebud\u00fa \u010falej h\u00fdba\u0165 zotrva\u010dnos\u0165ou.","title":"Spustenie programu"},{"location":"2motors/more/","text":"\u010eal\u0161ie \u00falohy Pr\u00e1zdny 1 2 3 4 5 # V t\u00e9to \u00faloze si poprv\u00e9 vyzkou\u0161\u00edte napsat cel\u00fd program sami, nen\u00ed zde \u017e\u00e1dn\u00fd # p\u0159ipraven\u00fd k\u00f3d. Pomohou v\u00e1m p\u0159edchoz\u00ed \u00falohy, ze kter\u00fdch m\u016f\u017eete v\u011bci kop\u00edrovat. # # Napi\u0161te program, aby se robot nejprve oto\u010dil okolo sv\u00e9ho lev\u00e9ho kola, potom # vte\u0159inu st\u00e1l na m\u00edst\u011b a oto\u010dil se okolo prav\u00e9ho kola. Presn\u00fd pohyb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/usr/bin/env pybricks-micropython # Probl\u00e9m p\u0159edchoz\u00ed \u00falohy je v tom, \u017ee robot se n\u00e9 v\u017edy oto\u010d\u00ed o stejn\u00fd \u00fasek. # Nap\u0159\u00edklad pokud budou m\u00e9n\u011b nabit\u00e9 baterie nebo bude jin\u00fd povrch na zemi. Zde # si uk\u00e1\u017eeme funkci 'run_angle', kter\u00e1 funguje trochu jinak ne\u017e 'run'. Za\u010dneme # t\u00edm, co u\u017e zn\u00e1me: from pybricks.ev3devices import Motor from pybricks.parameters import Port lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) # Nyn\u00ed pou\u017eijeme 'run_angle', kter\u00e1 krom\u011b rychlosti pot\u0159ebuje v\u011bd\u011bt je\u0161t\u011b \u00fahel, # o kter\u00fd se m\u00e1 motor oto\u010dit. Pozor! Motor, n\u00e9 kolo. Pokud jsou mezi motorem # a kolem p\u0159evody, tak se kolo nemus\u00ed oto\u010dit o stejn\u011b jako motor. pravy_motor . run_angle ( 360 , 720 ) lavy_motor . run_angle ( 360 , 720 ) # Nejprve se prav\u00fd motor oto\u010dil rychlost\u00ed 360 o 720 stup\u0148\u016f. To jsou dv\u011b cel\u00e9 # rotace motoru, nebo\u0165 kruh m\u00e1 360 stup\u0148\u016f a 360 * 2 = 720. Zkuste to odpozorovat, # kdy\u017e robota spust\u00edte, jestli se opravdu oto\u010d\u00ed dvakr\u00e1t. # Vra\u0165te se k p\u0159edchoz\u00ed \u00faloze, ale pou\u017eijte 'run_angle' m\u00edsto 'run'. Opakovanie 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) # \u010casto chceme aby robot n\u011bco zopakoval, nap\u0159\u00edklad \"t\u0159ikr\u00e1t blikni!\". My zat\u00edm # um\u00edme jen h\u00fdbat motory, tak se zkus\u00edme posunout t\u0159ikr\u00e1t dop\u0159edu. lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 500 ) lavy_motor . hold () pravy_motor . hold () wait ( 100 ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 500 ) lavy_motor . hold () pravy_motor . hold () wait ( 100 ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 500 ) lavy_motor . hold () pravy_motor . hold () wait ( 100 ) # Nyn\u00ed to ud\u011bl\u00e1me jinak, m\u00edsto toho abychom kop\u00edrovali stejn\u00fd k\u00f3d pod sebe, # nap\u00ed\u0161eme ho jenom jednou a \u0159ekneme, aby ho provedl t\u0159ikr\u00e1t: for i in range ( 3 ): lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 500 ) lavy_motor . hold () pravy_motor . hold () wait ( 100 ) # V\u0161imn\u011bte si, \u017ee v\u0161echny \u0159\u00e1dky pod prvn\u00edm \u0159\u00e1dkem (se slovem 'for') jsou # posunut\u00e9 o 4 mezery vpravo. \u0158\u00e1dek takto posunete, kdy\u017e nastav\u00edte kurzor na # za\u010d\u00e1tek \u0159\u00e1dku a potom stisknete tabul\u00e1tor (na kl\u00e1vesnici je hned nad # caps-lockem). Zkuste zm\u011bnit program tak, aby \u0161el dop\u0159edu a\u017e 5 kr\u00e1t. Opakovanie -- \u0161tvorec 1 2 3 4 # Pamatujete si, jak jste programovali robota, aby \u0161el do \u010dtverce? Tak\u00e9 tam # bylo opakov\u00e1n\u00ed - \u010dty\u0159ikr\u00e1t jste napsali za sebe stejn\u00fd k\u00f3d. \u010cty\u0159ikr\u00e1t \u0161el # robot dop\u0159edu a oto\u010dil se do strany. Nyn\u00ed pou\u017eijeme nov\u00fd zp\u016fsob s 'for i in # range( ? )'. Opakovanie -- i 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env pybricks-micropython # P\u0159e\u010dt\u011bte si tento program, spus\u0165te ho a potom n\u00e1m vysv\u011btl\u00edte jak funguje :) # Nebojte se experimentovat a upravovat ho, aby jste si vyzkou\u0161eli, \u017ee to # opravdu funguje tak, jak si mysl\u00edte. from pybricks.ev3devices import Motor from pybricks.parameters import Port lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) for i in range ( 5 ): lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( i * 500 ) # `*` znamen\u00e1 n\u00e1sobenie lavy_motor . hold () pravy_motor . hold () wait ( 100 )","title":"\u010eal\u0161ie \u00falohy"},{"location":"2motors/more/#dalsie-ulohy","text":"Pr\u00e1zdny 1 2 3 4 5 # V t\u00e9to \u00faloze si poprv\u00e9 vyzkou\u0161\u00edte napsat cel\u00fd program sami, nen\u00ed zde \u017e\u00e1dn\u00fd # p\u0159ipraven\u00fd k\u00f3d. Pomohou v\u00e1m p\u0159edchoz\u00ed \u00falohy, ze kter\u00fdch m\u016f\u017eete v\u011bci kop\u00edrovat. # # Napi\u0161te program, aby se robot nejprve oto\u010dil okolo sv\u00e9ho lev\u00e9ho kola, potom # vte\u0159inu st\u00e1l na m\u00edst\u011b a oto\u010dil se okolo prav\u00e9ho kola. Presn\u00fd pohyb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #!/usr/bin/env pybricks-micropython # Probl\u00e9m p\u0159edchoz\u00ed \u00falohy je v tom, \u017ee robot se n\u00e9 v\u017edy oto\u010d\u00ed o stejn\u00fd \u00fasek. # Nap\u0159\u00edklad pokud budou m\u00e9n\u011b nabit\u00e9 baterie nebo bude jin\u00fd povrch na zemi. Zde # si uk\u00e1\u017eeme funkci 'run_angle', kter\u00e1 funguje trochu jinak ne\u017e 'run'. Za\u010dneme # t\u00edm, co u\u017e zn\u00e1me: from pybricks.ev3devices import Motor from pybricks.parameters import Port lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) # Nyn\u00ed pou\u017eijeme 'run_angle', kter\u00e1 krom\u011b rychlosti pot\u0159ebuje v\u011bd\u011bt je\u0161t\u011b \u00fahel, # o kter\u00fd se m\u00e1 motor oto\u010dit. Pozor! Motor, n\u00e9 kolo. Pokud jsou mezi motorem # a kolem p\u0159evody, tak se kolo nemus\u00ed oto\u010dit o stejn\u011b jako motor. pravy_motor . run_angle ( 360 , 720 ) lavy_motor . run_angle ( 360 , 720 ) # Nejprve se prav\u00fd motor oto\u010dil rychlost\u00ed 360 o 720 stup\u0148\u016f. To jsou dv\u011b cel\u00e9 # rotace motoru, nebo\u0165 kruh m\u00e1 360 stup\u0148\u016f a 360 * 2 = 720. Zkuste to odpozorovat, # kdy\u017e robota spust\u00edte, jestli se opravdu oto\u010d\u00ed dvakr\u00e1t. # Vra\u0165te se k p\u0159edchoz\u00ed \u00faloze, ale pou\u017eijte 'run_angle' m\u00edsto 'run'. Opakovanie 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) # \u010casto chceme aby robot n\u011bco zopakoval, nap\u0159\u00edklad \"t\u0159ikr\u00e1t blikni!\". My zat\u00edm # um\u00edme jen h\u00fdbat motory, tak se zkus\u00edme posunout t\u0159ikr\u00e1t dop\u0159edu. lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 500 ) lavy_motor . hold () pravy_motor . hold () wait ( 100 ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 500 ) lavy_motor . hold () pravy_motor . hold () wait ( 100 ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 500 ) lavy_motor . hold () pravy_motor . hold () wait ( 100 ) # Nyn\u00ed to ud\u011bl\u00e1me jinak, m\u00edsto toho abychom kop\u00edrovali stejn\u00fd k\u00f3d pod sebe, # nap\u00ed\u0161eme ho jenom jednou a \u0159ekneme, aby ho provedl t\u0159ikr\u00e1t: for i in range ( 3 ): lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 500 ) lavy_motor . hold () pravy_motor . hold () wait ( 100 ) # V\u0161imn\u011bte si, \u017ee v\u0161echny \u0159\u00e1dky pod prvn\u00edm \u0159\u00e1dkem (se slovem 'for') jsou # posunut\u00e9 o 4 mezery vpravo. \u0158\u00e1dek takto posunete, kdy\u017e nastav\u00edte kurzor na # za\u010d\u00e1tek \u0159\u00e1dku a potom stisknete tabul\u00e1tor (na kl\u00e1vesnici je hned nad # caps-lockem). Zkuste zm\u011bnit program tak, aby \u0161el dop\u0159edu a\u017e 5 kr\u00e1t. Opakovanie -- \u0161tvorec 1 2 3 4 # Pamatujete si, jak jste programovali robota, aby \u0161el do \u010dtverce? Tak\u00e9 tam # bylo opakov\u00e1n\u00ed - \u010dty\u0159ikr\u00e1t jste napsali za sebe stejn\u00fd k\u00f3d. \u010cty\u0159ikr\u00e1t \u0161el # robot dop\u0159edu a oto\u010dil se do strany. Nyn\u00ed pou\u017eijeme nov\u00fd zp\u016fsob s 'for i in # range( ? )'. Opakovanie -- i 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env pybricks-micropython # P\u0159e\u010dt\u011bte si tento program, spus\u0165te ho a potom n\u00e1m vysv\u011btl\u00edte jak funguje :) # Nebojte se experimentovat a upravovat ho, aby jste si vyzkou\u0161eli, \u017ee to # opravdu funguje tak, jak si mysl\u00edte. from pybricks.ev3devices import Motor from pybricks.parameters import Port lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) for i in range ( 5 ): lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( i * 500 ) # `*` znamen\u00e1 n\u00e1sobenie lavy_motor . hold () pravy_motor . hold () wait ( 100 )","title":"\u010eal\u0161ie \u00falohy"},{"location":"2motors/simple/","text":"Jednoduch\u00e9 \u00falohy Varovanie M\u00f4\u017ee nasta\u0165 probl\u00e9m, ke\u010f simul\u00e1tor nedobre napodob\u0148uje robota v realite. M\u00e1 ve\u013ek\u00fa zotrva\u010dnos\u0165 a po vypnut\u00ed motorov sa robot (v simul\u00e1tori) aj tak st\u00e1le h\u00fdbe vpred, hoci re\u00e1lny robot by st\u00e1l na mieste. Rie\u0161en\u00edm je prep\u00edsa\u0165 v\u0161etky .stop() na .hold() . To zaru\u010d\u00ed, \u017ee sa koles\u00e1 u\u017e nebud\u00fa \u010falej h\u00fdba\u0165 zotrva\u010dnos\u0165ou. 1. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 1. Co kdybychom spustili motory 2kr\u00e1t rychleji? Nebo je\u0161t\u011b v\u00edc? Jak # nejrychleji je um\u00edte spustit? lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 2. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 2. Nyn\u00ed bychom cht\u011bli na\u0161eho robota pustit do druh\u00e9 strany, aby \u0161el dozadu. # Jak byste to ud\u011blali? lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 3. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 3. Vyzkou\u0161ejte spustit jen jeden motor, druh\u00fdm se v\u016fbec nepohne. Jak\u00fd pohyb robot # ud\u011bl\u00e1? # Napi\u0161te program, kde se robot bude to\u010dit na m\u00edst\u011b. lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 4. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 4. A jak byste poslali robota do kruhu? P\u0159em\u00fd\u0161lejte nad t\u00edm, vyzkou\u0161ejte # si s programem pohr\u00e1t, co V\u00e1s napadne. lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 5. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 5. Roz\u0161i\u0159te program d\u00e1le, aby robot nejprve \u0161el jednu sekundu dop\u0159edu, pot\u00e9 # jednu sekundu dozadu. lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 6. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 6. Roz\u0161i\u0159te program d\u00e1le, aby robot nejprve \u0161el jednu sekundu dop\u0159edu, pot\u00e9 # jednu sekundu dozadu. # Nyn\u00ed chceme, aby mezit\u00edm je\u0161t\u011b 1 vte\u0159inu st\u00e1l na m\u00edst\u011b. lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 7. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 7. Naprogramujte robota tak, aby se oto\u010dil doprava. (Tedy ud\u011blal 90\u00b0 otocku) lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 8. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 8. Naprogramujte robota tak, aby \u0161el do \u010dtverce. lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop ()","title":"Jednoduch\u00e9 \u00falohy"},{"location":"2motors/simple/#jednoduche-ulohy","text":"Varovanie M\u00f4\u017ee nasta\u0165 probl\u00e9m, ke\u010f simul\u00e1tor nedobre napodob\u0148uje robota v realite. M\u00e1 ve\u013ek\u00fa zotrva\u010dnos\u0165 a po vypnut\u00ed motorov sa robot (v simul\u00e1tori) aj tak st\u00e1le h\u00fdbe vpred, hoci re\u00e1lny robot by st\u00e1l na mieste. Rie\u0161en\u00edm je prep\u00edsa\u0165 v\u0161etky .stop() na .hold() . To zaru\u010d\u00ed, \u017ee sa koles\u00e1 u\u017e nebud\u00fa \u010falej h\u00fdba\u0165 zotrva\u010dnos\u0165ou. 1. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 1. Co kdybychom spustili motory 2kr\u00e1t rychleji? Nebo je\u0161t\u011b v\u00edc? Jak # nejrychleji je um\u00edte spustit? lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 2. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 2. Nyn\u00ed bychom cht\u011bli na\u0161eho robota pustit do druh\u00e9 strany, aby \u0161el dozadu. # Jak byste to ud\u011blali? lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 3. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 3. Vyzkou\u0161ejte spustit jen jeden motor, druh\u00fdm se v\u016fbec nepohne. Jak\u00fd pohyb robot # ud\u011bl\u00e1? # Napi\u0161te program, kde se robot bude to\u010dit na m\u00edst\u011b. lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 4. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 4. A jak byste poslali robota do kruhu? P\u0159em\u00fd\u0161lejte nad t\u00edm, vyzkou\u0161ejte # si s programem pohr\u00e1t, co V\u00e1s napadne. lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 5. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 5. Roz\u0161i\u0159te program d\u00e1le, aby robot nejprve \u0161el jednu sekundu dop\u0159edu, pot\u00e9 # jednu sekundu dozadu. lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 6. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 6. Roz\u0161i\u0159te program d\u00e1le, aby robot nejprve \u0161el jednu sekundu dop\u0159edu, pot\u00e9 # jednu sekundu dozadu. # Nyn\u00ed chceme, aby mezit\u00edm je\u0161t\u011b 1 vte\u0159inu st\u00e1l na m\u00edst\u011b. lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 7. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 7. Naprogramujte robota tak, aby se oto\u010dil doprava. (Tedy ud\u011blal 90\u00b0 otocku) lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop () 8. \u00dakol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/usr/bin/env pybricks-micropython from pybricks.ev3devices import Motor from pybricks.parameters import Port from pybricks.tools import wait # 8. Naprogramujte robota tak, aby \u0161el do \u010dtverce. lavy_motor = Motor ( Port . B ) pravy_motor = Motor ( Port . C ) lavy_motor . run ( 360 ) pravy_motor . run ( 360 ) wait ( 2000 ) lavy_motor . stop () pravy_motor . stop ()","title":"Jednoduch\u00e9 \u00falohy"}]}